#!/usr/local/bin/bash

#
# Vocabulary:
#
# Container:  A running image.
# Context:    All the files that can be accessed while an image is being built. Must include Dockerfile.
# Image:      Static file built from a context.
# Image name: Uniquely identifies a built image. Format is repository:tag
#
# TODO: Maybe allowing multiple Dockerfiles in a single context is a good idea. For right now, even if it is, neither
#       this script nor I will help you. Haha, suffer!
#

set -e
set -o pipefail
shopt -s inherit_errexit

# Include guard.
if [[ -n "${COMMON_29348759287345978}" ]]; then
  return
else
  declare -r COMMON_29348759287345978=1
fi

# Config that actually belongs here (i.e. config about this repo).
declare -r CONTEXTS_BASE='contexts'

# Config that doesn't belong here.
declare -r AWK_EXECUTABLE='awk'
declare -r AWS_EXECUTABLE='aws'
declare -r AWS_PROFILE_NAME='home'
declare -r AWS_REGION='us-east-1'
declare -r CONTROLLER_IMAGE_NAME='controller'
declare -r DEBUG_FILE_DESCRIPTOR=2
declare -r DEBUG_SHELL_COMMANDS='true'
declare -r DNS_DOMAIN='lepertheory.net'
declare -r DOCKER_REGISTRY='574271486042.dkr.ecr.us-east-1.amazonaws.com'
declare -r GIT_EXECUTABLE='git'
declare -r JQ_EXECUTABLE='jq'
declare -r LOCAL_AWS_CONFIG="${HOME}/.aws-docker"
declare -r ERROR_FILE_DESCRIPTOR=2

# This also probably doesn't belong here.
declare -A EXECUTABLES
EXECUTABLES[awk]="$(which awk)"
EXECUTABLES[aws]="$(which aws)"
EXECUTABLES[git]="$(which git)"
EXECUTABLES[jq]="$(which jq)"

#
# Log into the AWS docker registry.
#
awsDockerLogin()
{
  local docker_login_command; docker_login_command=($(runAws ecr get-login --no-include-email))

  run "${docker_login_command[@]}"
}

#
# Build an image from a local (within CONTEXT_BASE) repository name.
#
buildImage()
{
  local -r REPOSITORY_NAME="${1}"
  if [[ -z "${REPOSITORY_NAME}" ]]; then
    echo 'REPOSITORY_NAME is required.' 1>&${ERROR_FILE_DESCRIPTOR}
    exit 1
  fi
  shift

  local absolute_contexts_base; absolute_contexts_base="$(run getContextsBase)"; local -r ABSOLUTE_CONTEXTS_BASE="${absolute_contexts_base}"
  local git_branch; git_branch="$(run getGitBranch)"; local -r GIT_BRANCH="${git_branch}"
  local docker_tag; docker_tag="$(run getDockerTag)"; local -r DOCKER_TAG="${docker_tag}"
  local -r ABSOLUTE_CONTEXT="${ABSOLUTE_CONTEXTS_BASE}/${REPOSITORY_NAME}"
  local -r REPO_SOURCE="${CONTEXTS_BASE}/${CONTEXT}"

  # Build parent if it's ours.
  local base_image_name; base_image_name="$(run getBaseImage "${ABSOLUTE_CONTEXT}")"; local -r BASE_IMAGE_NAME="${base_image_name}"
  local base_docker_repository; base_docker_repository="$(run getDockerRepository "${BASE_IMAGE_NAME}")"; local -r BASE_DOCKER_REPOSITORY="${base_docker_repository}"
  local -r ABSOLUTE_BASE_CONTEXT="${ABSOLUTE_CONTEXTS_BASE}/${BASE_DOCKER_REPOSITORY}"
  local -r ABSOLUTE_BASE_DOCKERFILE="${ABSOLUTE_BASE_CONTEXT}"/Dockerfile
  if [[ -f "${ABSOLUTE_BASE_DOCKERFILE}" ]]; then
    run buildImage "${BASE_DOCKER_REPOSITORY}"
  fi

  if [[ -x "${ABSOLUTE_CONTEXT}"/build_pre ]]; then
    "${ABSOLUTE_CONTEXT}"/build_pre
  fi

  local build_command=(docker build)
  local build_command+=(--build-arg GIT_BRANCH="${GIT_BRANCH}")
  local build_command+=(--tag "${REPOSITORY_NAME}:${DOCKER_TAG}")
  local build_command+=(--label REPO_SOURCE="${REPO_SOURCE}")
  if [[ -f "${ABSOLUTE_BASE_DOCKERFILE}" ]]; then
    # FIXME: The test doesn't match the value. We test for absolute path, then set a relative one.
    build_command+=(--label BASE_DOCKERFILE="${CONTEXTS_BASE}/${BASE_DOCKER_REPOSITORY}"/Dockerfile)
  fi
  while [[ "${1}" == '--dockerArg' ]]; do
    shift
    build_command+=("${1}")
    shift
  done
  build_command+=("${ABSOLUTE_CONTEXT}")

  run "${build_command[@]}"
}

#
# Get the current user's account ID. This seems like a terrible way, but I can't figure out anything better right now.
#
# Returns: The current profile's AWS account ID.
#
getAwsAccountId()
{
  runAws iam get-user | run jq --raw-output '.User.Arn' | run awk -F: '{ print $5 }'
}

#
# Get arguments needed to use an alternate AWS CLI profile.
#
# Returns: Command-line arguments to specify the AWS CLI configuration profile to use.
#
getAwsProfileArguments()
{
  if [[ -n "${AWS_PROFILE_NAME}" ]]; then
    echo -n "--profile=${AWS_PROFILE_NAME}"
  fi
}

#
# Get the image required to build an image from a context.
#
# CONTEXT: The context for the image you want to build.
#
# Returns: An image name.
#
getBaseImage()
{
  local -r CONTEXT="${1}"
  if [[ -z "${CONTEXT}" ]]; then
    echo 'CONTEXT is required.' 1>&${ERROR_FILE_DESCRIPTOR}
    exit 1
  fi

  local git_branch; git_branch="$(getGitBranch)"; local -r GIT_BRANCH="${git_branch}"
  local base_image_raw; base_image_raw="$(run sed -En 's/^\s*FROM\s+//p' "${CONTEXT}"/Dockerfile)"; local -r BASE_IMAGE_RAW="${base_image_raw}"
  local -ar REPLACEMENTS_APPLIED="("${BASE_IMAGE_RAW}")"
  echo "${REPLACEMENTS_APPLIED}"
}

#
# Get the directory contexts are stored in.
#
# Returns: An absolute path.
#
getContextsBase()
{
  local git_repo; git_repo="$(run getGitRepo)"; local -r GIT_REPO="${git_repo}"

  echo "${GIT_REPO}/${CONTEXTS_BASE}"
}

#
# This is silly, but Docker calls these things repositories.
#
# IMAGE_NAME: A string formatted as "repository[:tag]"
#
# Returns: "repository"
#
getDockerRepository()
{
  local -r IMAGE_NAME="${1}"
  if [[ -z "${IMAGE_NAME}" ]]; then
    echo 'IMAGE NAME is required.' 1>&${ERROR_FILE_DESCRIPTOR}
    exit 1
  fi

  echo "${IMAGE_NAME%%:*}"
}

#
# Get the tag to apply to images.
#
# Return: A docker tag, probably the git branch.
#
getDockerTag()
{
  getGitBranch
}

#
# Get the currently checked-out Git branch.
#
# Returns: A short branch name.
#
getGitBranch()
{
  local git_repo; git_repo="$(run getGitRepo)"; local -r GIT_REPO="${git_repo}"

  run cd "${GIT_REPO}"
  run git symbolic-ref --short HEAD
}

#
# Get the root directory of the Git repo this script lives in.
#
# Returns: An absolute path.
#
getGitRepo()
{
  local script_dir; script_dir="$(run dirname "${BASH_SOURCE[0]}")"; local -r SCRIPT_DIR="${script_dir}"

  run cd "${SCRIPT_DIR}"
  run git rev-parse --show-toplevel
}

#
# Run a command, optionally logging the command itself.
#
# ARGV... Just what you'd enter on the command-line. The first element may be overridden by values in the global
#           associative array EXECUTABLES.
#
run()
{
  if (( ${#} < 1 )); then
    echo 'A command must be supplied.' 1>&${ERROR_FILE_DESCRIPTOR}
    exit 1
  fi

  # Build the command to be run, applying replacement to the first element.
  local -a command
  for arg in "${@}"; do
    if (( ${#command[@]} == 0 )) && [[ -n "${EXECUTABLES[${arg}]}" ]]; then
      command+=("${EXECUTABLES[${arg}]}")
    else
      command+=("${arg}")
    fi
  done

  # Log run commands.
  if [[ "${DEBUG_SHELL_COMMANDS}" == 'true' ]]; then
    local -a log_output
    for arg in "${command[@]}"; do
      if (( ${#log_output[@]} == 0 )); then
        log_output+=("$(caller) executing:")
      fi
      log_output+=("$(printf '%q' "${arg}")")
    done
    echo "${log_output[@]}" 1>&${DEBUG_FILE_DESCRIPTOR}
  fi

  "${command[@]}"
}

#
# Run an AWS CLI command.
#
runAws()
{
  local aws_command_base_arguments=(aws)

  # You don't want this unless you're running multiple profiles.
  aws_command_base_arguments+=($(run getAwsProfileArguments))

  # This is probably required. I don't know, or care at this point.
  if [[ -n "${AWS_REGION}" ]]; then
    aws_command_base_arguments+=("--region=${AWS_REGION}")
  fi

  # If you remove this, the rest of this script won't know wtf.
  aws_command_base_arguments+=(--output=json)

  run "${aws_command_base_arguments[@]}" "${@}"
}












getParentImage()
{
  set -e
  set -o pipefail

  local -r CONTEXT="${1}"
  if [[ -z "${CONTEXT}" ]]; then
    echo 'CONTEXT is required.' 1>&2
    exit 1
  fi

  local BASE_IMAGE="$(getBaseImage "${DIRECTORY}")"
  if [[ "${BASE_IMAGE}" == 'alpine:latest' ]]; then
    return 0
  else
    echo "$(getDockerfile "${BASE_IMAGE}" || echo -n)"
  fi
}

ensureContainerIsRunningInBackground()
{
  set -e
  set -o pipefail

  local TAGGED_IMAGE_NAME="${1}"
  if [[ -z "${TAGGED_IMAGE_NAME}" ]]; then
    echo 'TAGGED_IMAGE_NAME is required.' 1>&2
    exit 1
  fi

  ensureContainerExists "${TAGGED_IMAGE_NAME}"
  ensureImageExists "${TAGGED_IMAGE_NAME}"
}

ensureContainerExists()
{
  set -e
  set -o pipefail

  local TAGGED_IMAGE_NAME="${1}"
  if [[ -z "${TAGGED_IMAGE_NAME}" ]]; then
    echo 'TAGGED_IMAGE_NAME is required.' 1>&2
    exit 1
  fi

  #if [[ -z "$(docker ps --all --quiet)" ]]; then
  #
  #fi
}

ensureImageExists()
{
  set -e
  set -o pipefail

  local IMAGE_NAME_AND_TAG="${1}"
  if [[ -z "${IMAGE_NAME_AND_TAG}" ]]; then
    echo 'IMAGE_NAME_AND_TAG is required.' 1>&2
    exit 1
  fi

  local IMAGE_NAME="${IMAGE_NAME_AND_TAG%%:*}"
  local IMAGE_TAG="${IMAGE_NAME_AND_TAG#*:}"
  if [[ "${IMAGE_TAG}" != "$(getGitBranch)" ]]; then
    echo 'Unhandled. Deal.' 1>&2
    exit 2
  fi

  if [[ -z "$(docker images -q "${IMAGE_NAME_AND_TAG}")" ]]; then
    buildDockerImage "$(getImageDirectory "${IMAGE_NAME}")"
  fi
}

getAwsImageName()
{
  set -e
  set -o pipefail

  local DIRECTORY="${1}"
  if [[ -z "${DIRECTORY}" ]]; then
    echo 'DIRECTORY is required.' 1>&2
    exit 1
  fi

  echo "${DOCKER_REPO}/$(getTaggedDockerImageName "${DIRECTORY}")"
}

getDockerfile()
{
  set -e
  set -o pipefail

  local TAGGED_IMAGE_NAME="${1}"
  if [[ -z "${TAGGED_IMAGE_NAME}" ]]; then
    echo 'TAGGED_IMAGE_NAME is required.' 1>&2
    exit 1
  fi

  local POTENTIAL_DOCKERFILE="$(getGitRepo)/${IMAGES_BASE}/${TAGGED_IMAGE_NAME%%:*}/Dockerfile"
  if [[ -f "${POTENTIAL_DOCKERFILE}" ]]; then
    echo "${POTENTIAL_DOCKERFILE}"
  else
    return 1
  fi
}

getDockerContainerInfoByName()
{
  set -e
  set -o pipefail

  local CONTAINER_NAME="${1}"
  if [[ -z "${CONTAINER_NAME}" ]]; then
    echo 'CONTAINER_NAME is required.' 1>&2
    exit 1
  fi

  NAME_ID_IMAGE=($(docker ps --no-trunc --format '{{.Names}} {{.ID}} {{.Image}}' | \
                   grep -E '^'"${CONTAINER_NAME}"'\s+'))
  echo "${NAME_ID_IMAGE[@]}"
}

getDockerImageSources()
{
  set -e
  set -o pipefail

  local docker_image_sources=( )
  while IFS= read -r -d '' dir; do
    docker_image_sources+=("${dir}")
  done < <(find "$(getDockerImagesBase)" -maxdepth 1 -mindepth 1 -type d -print0)

  echo "${docker_image_sources[@]}"
}

getDockerImageDirectory()
{
  set -e
  set -o pipefail

  local IMAGE_NAME="${1}"
  if [[ -z "${IMAGE_NAME}" ]]; then
    echo 'IMAGE_NAME is required.' 1>&2
    exit 1
  fi

  echo "$(getDockerImagesBase)/${IMAGE_NAME}"
}

getDockerImageName()
{
  set -e
  set -o pipefail

  local DIRECTORY="${1}"
  if [[ -z "${DIRECTORY}" ]]; then
    echo 'DIRECTORY is required.' 1>&2
    exit 1
  fi

  basename "$(cd "${DIRECTORY}" && pwd)"
}

getDockerImageEnvironmentVariableByDirectory()
{
  set -e
  set -o pipefail

  local DIRECTORY="${1}"
  local ENVIRONMENT_VARIABLE="${2}"
  if [[ -z "${DIRECTORY}" ]] || [[ -z "${ENVIRONMENT_VARIABLE}" ]]; then
    echo 'DIRECTORY and ENVIRONMENT_VARIABLE are required.' 1>&2
    exit 1
  fi

  getDockerImageEnvironmentVariableByTaggedDockerImageName "$(getTaggedDockerImageName "${DIRECTORY}")" \
                                                           "${ENVIRONMENT_VARIABLE}"
}

getDockerImageEnvironmentVariableByTaggedDockerImageName()
{
  set -e
  set -o pipefail

  local TAGGED_DOCKER_IMAGE_NAME="${1}"
  local ENVIRONMENT_VARIABLE="${2}"
  if [[ -z "${TAGGED_DOCKER_IMAGE_NAME}" ]] || [[ -z "${ENVIRONMENT_VARIABLE}" ]]; then
    echo 'TAGGED_DOCKER_IMAGE_NAME and ENVIRONMENT_VARIABLE are required.' 1>&2
    exit 1
  fi

  docker inspect "${TAGGED_DOCKER_IMAGE_NAME}" | \
    $(runJq) --raw-output '.[0].Config.Env[] | select(startswith("'"${ENVIRONMENT_VARIABLE}"'=")) | split("=")[1:] | join("=")'
}

getDockerImageLabelByTaggedDockerImageName()
{
  set -e
  set -o pipefail

  local TAGGED_DOCKER_IMAGE_NAME="${1}"
  local LABEL="${2}"
  if [[ -z "${TAGGED_DOCKER_IMAGE_NAME}" ]] || [[ -z "${LABEL}" ]]; then
    echo 'TAGGED_DOCKER_IMAGE_NAME and LABEL are required.' 1>&2
    exit 1
  fi

  docker inspect "${TAGGED_DOCKER_IMAGE_NAME}" | \
    $(runJq) --raw-output '.[0].Config.Labels.'"${LABEL}"
}

getDockerImageLabelByDirectory()
{
  set -e
  set -o pipefail

  local DIRECTORY="${1}"
  local LABEL="${2}"
  if [[ -z "${DIRECTORY}" ]] || [[ -z "${LABEL}" ]]; then
    echo 'DIRECTORY and LABEL are required.' 1>&2
    exit 1
  fi

  getDockerImageLabelByTaggedDockerImageName "$(getTaggedDockerImageName "${DIRECTORY}")" "${LABEL}"
}

getDockerImagesBase()
{
  set -e
  set -o pipefail

  echo "$(getGitRepo)/${IMAGES_BASE}"
}

getGitRootFromPath()
{
  set -e
  set -o pipefail

  CHECK_PATH="${1}"
  if [[ -z "${CHECK_PATH}" ]]; then
    echo 'CHECK_PATH is required.' 1>&2
    exit 1
  fi

  realpath --relative-to="$(getGitRepo)" "${CHECK_PATH}"
}

getTaggedDockerImageName()
{
  set -e
  set -o pipefail

  local DIRECTORY="${1}"
  if [[ -z "${DIRECTORY}" ]]; then
    echo 'DIRECTORY is required.' 1>&2
    exit 1
  fi

  echo "$(getDockerImageName "${DIRECTORY}"):$(getDockerTag)"
}

isDockerContainerNameRunning()
{
  set -e
  set -o pipefail

  local CONTAINER_NAME="${1}"
  if [[ -z "${CONTAINER_NAME}" ]]; then
    echo 'CONTAINER_NAME is required.' 1>&2
    exit 1
  fi

  local CONTAINER_INFO=($(getDockerContainerInfoByName "${CONTAINER_NAME}"))
  return $(( ${#CONTAINER_INFO[@]} != 3 ))
}

runInDockerContainer()
{
  set -e
  set -o pipefail

  local CONTAINER_NAME="${1}"
  if [[ -z "${CONTAINER_NAME}" ]]; then
    echo 'CONTAINER_NAME is required.' 1>&2
    exit 1
  fi

  ensureContainerExists "${CONTAINER_NAME}"

  local -a docker_command=(docker)
  if isDockerContainerNameRunning "${CONTAINER_NAME}"; then
    docker_command+=(exec)
  else
    docker_command+=(run)
  fi

  if [[ -t 0 ]]; then
    docker_command+=(--tty)
    docker_command+=(--env TERM="${TERM}")
  fi

  # Not sure why this isn't conditional.
  docker_command+=(--interactive)

  getDockerImageDirectory
}

if [[ "${0}" == "${BASH_SOURCE[0]}" ]]; then
  run "${@}"
fi

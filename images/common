#!/usr/bin/env bash

set -e
set -o pipefail

if [[ -n "${COMMON_29348759287345978}" ]]; then
  return
else
  COMMON_29348759287345978=1
fi

DEBUG=$((true))
DNS_DOMAIN='lepertheory.net'
DOCKER_REPO='574271486042.dkr.ecr.us-east-1.amazonaws.com'
IMAGES_BASE='images'
DOCKER_ROOT_HOME="${HOME}/.aws-docker"
BASE_DOCKER_NAME='base'
CONTROLLER_DOCKER_NAME='controller'

buildDockerImage()
{
  set -e
  set -o pipefail

  local DIRECTORY="${1}"
  if [[ -z "${DIRECTORY}" ]]; then
    echo 'DIRECTORY is required.' 1>&2
    exit 1
  fi
  shift

  local BASE_DOCKERFILE="$(getParentDockerImageSource "${DIRECTORY}")"
  if [[ -f "${BASE_DOCKERFILE}" ]]; then
    buildDockerImage "$(dirname "${BASE_DOCKERFILE}")"
  else
    echo "Dockerfile ${BASE_DOCKERFILE} not found."
    exit 2
  fi

  if [[ -x "${DIRECTORY}"/build_pre ]]; then
    "${DIRECTORY}"/build_pre
  fi

  local build_command=(docker build)
  local build_command+=(--build-arg GIT_BRANCH="$(getGitBranch)")
  local build_command+=(--tag "$(getTaggedDockerImageName "${DIRECTORY}")")
  local build_command+=(--label REPO_SOURCE="$(getGitRepoPath "${DIRECTORY}")")
  if [[ -f "${BASE_DOCKERFILE}" ]]; then
    build_command+=(--label BASE_DOCKERFILE="$(getGitRepoPath "${BASE_DOCKERFILE}")")
  fi
  while [[ "${1}" == '--dockerArg' ]]; do
    shift
    build_command+=("${1}")
    shift
  done
  build_command+=("${DIRECTORY}")
  
  if [[ ${DEBUG} ]]; then
    echo "build_command: ${build_command[@]}"
  fi
  "${build_command[@]}"
}

getParentDockerImageSource()
{
  set -e
  set -o pipefail

  local DIRECTORY="${1}"
  if [[ -z "${DIRECTORY}" ]]; then
    echo 'DIRECTORY is required.' 1>&2
    exit 1
  fi

  local BASE_IMAGE="$(getBaseImage "${DIRECTORY}")"
  if [[ "${BASE_IMAGE}" == 'alpine:latest' ]]; then
    return 0
  else
    echo "$(getDockerfile "${BASE_IMAGE}" || echo -n)"
  fi
}

ensureContainerIsRunningInBackground()
{
  set -e
  set -o pipefail

  local TAGGED_IMAGE_NAME="${1}"
  if [[ -z "${TAGGED_IMAGE_NAME}" ]]; then
    echo 'TAGGED_IMAGE_NAME is required.' 1>&2
    exit 1
  fi

  ensureContainerExists "${TAGGED_IMAGE_NAME}"
  ensureImageExists "${TAGGED_IMAGE_NAME}"
}

ensureContainerExists()
{
  set -e
  set -o pipefail

  local TAGGED_IMAGE_NAME="${1}"
  if [[ -z "${TAGGED_IMAGE_NAME}" ]]; then
    echo 'TAGGED_IMAGE_NAME is required.' 1>&2
    exit 1
  fi

  #if [[ -z "$(docker ps --all --quiet)" ]]; then
  #
  #fi
}

ensureImageExists()
{
  set -e
  set -o pipefail

  local IMAGE_NAME_AND_TAG="${1}"
  if [[ -z "${IMAGE_NAME_AND_TAG}" ]]; then
    echo 'IMAGE_NAME_AND_TAG is required.' 1>&2
    exit 1
  fi

  local IMAGE_NAME="${IMAGE_NAME_AND_TAG%%:*}"
  local IMAGE_TAG="${IMAGE_NAME_AND_TAG#*:}"
  if [[ "${IMAGE_TAG}" != "$(getGitBranch)" ]]; then
    echo 'Unhandled. Deal.' 1>&2
    exit 2
  fi

  if [[ -z "$(docker images -q "${IMAGE_NAME_AND_TAG}")" ]]; then
    buildDockerImage "$(getImageDirectory "${IMAGE_NAME}")"
  fi
}

getAwsImageName()
{
  set -e
  set -o pipefail

  local DIRECTORY="${1}"
  if [[ -z "${DIRECTORY}" ]]; then
    echo 'DIRECTORY is required.' 1>&2
    exit 1
  fi

  echo "${DOCKER_REPO}/$(getTaggedDockerImageName "${DIRECTORY}")"
}

getBaseImage()
{
  set -e
  set -o pipefail

  local DIRECTORY="${1}"
  if [[ -z "${DIRECTORY}" ]]; then
    echo 'DIRECTORY is required.' 1>&2
    exit 1
  fi

  eval "GIT_BRANCH=\"$(getGitBranch)\"; echo \"$(grep -E '^FROM ' "${DIRECTORY}"/Dockerfile | sed -E 's/FROM\s+//')\""
}

getDockerfile()
{
  set -e
  set -o pipefail

  local TAGGED_IMAGE_NAME="${1}"
  if [[ -z "${TAGGED_IMAGE_NAME}" ]]; then
    echo 'TAGGED_IMAGE_NAME is required.' 1>&2
    exit 1
  fi

  local POTENTIAL_DOCKERFILE="$(getGitRepo)/${IMAGES_BASE}/${TAGGED_IMAGE_NAME%%:*}/Dockerfile"
  if [[ -f "${POTENTIAL_DOCKERFILE}" ]]; then
    echo "${POTENTIAL_DOCKERFILE}"
  else
    return 1
  fi
}

getDockerContainerInfoByName()
{
  set -e
  set -o pipefail

  local CONTAINER_NAME="${1}"
  if [[ -z "${CONTAINER_NAME}" ]]; then
    echo 'CONTAINER_NAME is required.' 1>&2
    exit 1
  fi

  NAME_ID_IMAGE=($(docker ps --no-trunc --format '{{.Names}} {{.ID}} {{.Image}}' | \
                   grep -E '^'"${CONTAINER_NAME}"'\s+'))
  echo "${NAME_ID_IMAGE[@]}"
}

getDockerImageSources()
{
  set -e
  set -o pipefail

  local docker_image_sources=( )
  while IFS= read -r -d '' dir; do
    docker_image_sources+=("${dir}")
  done < <(find "$(getDockerImagesBase)" -maxdepth 1 -mindepth 1 -type d -print0)

  echo "${docker_image_sources[@]}"
}

getDockerImageDirectory()
{
  set -e
  set -o pipefail

  local IMAGE_NAME="${1}"
  if [[ -z "${IMAGE_NAME}" ]]; then
    echo 'IMAGE_NAME is required.' 1>&2
    exit 1
  fi

  echo "$(getDockerImagesBase)/${IMAGE_NAME}"
}

getDockerImageName()
{
  set -e
  set -o pipefail

  local DIRECTORY="${1}"
  if [[ -z "${DIRECTORY}" ]]; then
    echo 'DIRECTORY is required.' 1>&2
    exit 1
  fi

  basename "$(cd "${DIRECTORY}" && pwd)"
}

getDockerImageEnvironmentVariableByDirectory()
{
  set -e
  set -o pipefail

  local DIRECTORY="${1}"
  local ENVIRONMENT_VARIABLE="${2}"
  if [[ -z "${DIRECTORY}" ]] || [[ -z "${ENVIRONMENT_VARIABLE}" ]]; then
    echo 'DIRECTORY and ENVIRONMENT_VARIABLE are required.' 1>&2
    exit 1
  fi

  getDockerImageEnvironmentVariableByTaggedDockerImageName "$(getTaggedDockerImageName "${DIRECTORY}")" \
                                                           "${ENVIRONMENT_VARIABLE}"
}

getDockerImageEnvironmentVariableByTaggedDockerImageName()
{
  set -e
  set -o pipefail

  local TAGGED_DOCKER_IMAGE_NAME="${1}"
  local ENVIRONMENT_VARIABLE="${2}"
  if [[ -z "${TAGGED_DOCKER_IMAGE_NAME}" ]] || [[ -z "${ENVIRONMENT_VARIABLE}" ]]; then
    echo 'TAGGED_DOCKER_IMAGE_NAME and ENVIRONMENT_VARIABLE are required.' 1>&2
    exit 1
  fi

  docker inspect "${TAGGED_DOCKER_IMAGE_NAME}" | \
    $(runJq) --raw-output '.[0].Config.Env[] | select(startswith("'"${ENVIRONMENT_VARIABLE}"'=")) | split("=")[1:] | join("=")'
}

getDockerImageLabelByTaggedDockerImageName()
{
  set -e
  set -o pipefail

  local TAGGED_DOCKER_IMAGE_NAME="${1}"
  local LABEL="${2}"
  if [[ -z "${TAGGED_DOCKER_IMAGE_NAME}" ]] || [[ -z "${LABEL}" ]]; then
    echo 'TAGGED_DOCKER_IMAGE_NAME and LABEL are required.' 1>&2
    exit 1
  fi

  docker inspect "${TAGGED_DOCKER_IMAGE_NAME}" | \
    $(runJq) --raw-output '.[0].Config.Labels.'"${LABEL}"
}

getDockerImageLabelByDirectory()
{
  set -e
  set -o pipefail

  local DIRECTORY="${1}"
  local LABEL="${2}"
  if [[ -z "${DIRECTORY}" ]] || [[ -z "${LABEL}" ]]; then
    echo 'DIRECTORY and LABEL are required.' 1>&2
    exit 1
  fi

  getDockerImageLabelByTaggedDockerImageName "$(getTaggedDockerImageName "${DIRECTORY}")" "${LABEL}"
}

getDockerImagesBase()
{
  set -e
  set -o pipefail

  echo "$(getGitRepo)/${IMAGES_BASE}"
}

getDockerTag()
{
  set -e
  set -o pipefail

  getGitBranch
}

getGitBranch()
{
  set -e
  set -o pipefail

  cd "$(getGitRepo)"
  git symbolic-ref --short HEAD
}

getGitRepoPath()
{
  set -e
  set -o pipefail

  CHECK_PATH="${1}"
  if [[ -z "${CHECK_PATH}" ]]; then
    echo 'CHECK_PATH is required.' 1>&2
    exit 1
  fi

  realpath --relative-to="$(getGitRepo)" "${CHECK_PATH}"
}

getGitRepo()
{
  set -e
  set -o pipefail

  cd "$(dirname "${BASH_SOURCE[0]}")"
  git rev-parse --show-toplevel
}

getTaggedDockerImageName()
{
  set -e
  set -o pipefail

  local DIRECTORY="${1}"
  if [[ -z "${DIRECTORY}" ]]; then
    echo 'DIRECTORY is required.' 1>&2
    exit 1
  fi

  echo "$(getDockerImageName "${DIRECTORY}"):$(getDockerTag)"
}

isDockerContainerNameRunning()
{
  set -e
  set -o pipefail

  local CONTAINER_NAME="${1}"
  if [[ -z "${CONTAINER_NAME}" ]]; then
    echo 'CONTAINER_NAME is required.' 1>&2
    exit 1
  fi

  local CONTAINER_INFO=($(getDockerContainerInfoByName "${CONTAINER_NAME}"))
  return $(( ${#CONTAINER_INFO[@]} != 3 ))
}

runInDockerContainer()
{
  set -e
  set -o pipefail

  local CONTAINER_NAME="${1}"
  if [[ -z "${CONTAINER_NAME}" ]]; then
    echo 'CONTAINER_NAME is required.' 1>&2
    exit 1
  fi

  ensureContainerExists "${CONTAINER_NAME}"

  local -a docker_command=(docker)
  if isDockerContainerNameRunning "${CONTAINER_NAME}"; then
    docker_command+=(exec)
  else
    docker_command+=(run)
  fi

  if [[ -t 0 ]]; then
    docker_command+=(--tty)
    docker_command+=(--env TERM="${TERM}")
  fi

  # Not sure why this isn't conditional.
  docker_command+=(--interactive)

  getDockerImageDirectory
}

runJq()
{
  "$(getDockerImagesBase)"/run "$(getDockerImagesBase)/${CONTROLLER_DOCKER_NAME}" <&0
}

#topoSort

if [[ "${0}" == "${BASH_SOURCE[0]}" ]]; then
  "${@}"
fi
